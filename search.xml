<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用C++进行QGis开发之]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%88%A9%E7%94%A8C-%E8%BF%9B%E8%A1%8CQGis%E5%BC%80%E5%8F%91%E4%B9%8B-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E5%9B%BE%E5%B1%82%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%A6%81%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[其实本文实现的功能类似于QGis中“添加文本数据图层”的一个简化版，本文不会涉及到对话框的使用，不通过与用户互交的方式创建要素，而是直接通过代码方式添加点要素，起到一个抛砖引玉的作用。 先将整个流程大概梳理下 首先创建一个临时(memory)矢量图层 ; 将创建的图层添加到地图画布中 ; 创建几何要素 ; 将几何要素添加到矢量图层中 ; 更新图层范围并刷新画布 。 程序整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 测试代码/* "Point?crs=EPSG:4326&amp;field=id:integer&amp; * field=name:string(50)&amp;index=yes&amp; * memoryid=&#123;63152c31-9f38-4410-9983-fc9abe84973f&#125;" */QString layerProperties = "Point?"; // 几何类型layerProperties.append(QString( "crs=EPSG:4326&amp;" )); // 参照坐标系layerProperties.append(QString( "field=id:integer&amp;field=name:string(50)&amp;" )); // 添加字段layerProperties.append(QString( "index=yes&amp;" )); // 创建索引layerProperties.append(QString( // 临时编码"memoryid=%1" ).arg( QUuid::createUuid().toString() ));QgsVectorLayer* newLayer = new QgsVectorLayer( layerProperties, QString( "临时点层" ), QString( "memory" ) );if (!newLayer-&gt;isValid())&#123; return false;&#125;// 添加到地图QgsMapLayerRegistry::instance()-&gt;addMapLayer(newLayer);QgsVectorDataProvider* dateProvider = newLayer-&gt;dataProvider();// 创建点QgsFeature MyFeature;MyFeature.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4443, 32.2123)) );MyFeature.setAttributes(QgsAttributes() &lt;&lt; QVariant(1) &lt;&lt; QVariant("test"));QgsFeature MyFeature1;MyFeature1.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4643, 32.2133)) );MyFeature1.setAttributes(QgsAttributes() &lt;&lt; QVariant(2) &lt;&lt; QVariant("test1"));// 开始编辑newLayer-&gt;startEditing();// 添加要素dateProvider-&gt;addFeatures(QgsFeatureList() &lt;&lt; MyFeature &lt;&lt; MyFeature1);// 保存newLayer-&gt;commitChanges();// 更新范围newLayer-&gt;updateExtents();mMapCanvas-&gt;refresh();return true; 代码分析 创建临时图层 第3-11行，这段代码可能是我与网上其他的教程中比较不一样的地方，这里通过构造一种URL形式的字符串，通过上面的注释大家应该都大概明白这个字符串的意思了，通过这种形式很简洁方便的使我们将要创建的图层具备了多个条件，特别是简化对于图层字段的添加。 第7行 QString layerProperties = &quot;Point?&quot;定义了我们创建图层的几何类型，可以是&quot;Point&quot;、&quot;LineString&quot;、&quot;Polygon&quot;、&quot;MultiPoint&quot;、&quot;MultiLineString&quot;、&quot;MultiPolygon&quot;其中之一。 第8行QString( &quot;crs=EPSG:4326&amp;&quot; )是图层的参照坐标系，定义一个正确的坐标系是一个良好的习惯，如果需要一定灵活性可以参照QGis的方式通过对话框选取，或是根据自己的需求来实现，需要改变的仅仅是&quot;EPSG:4326&quot;而已。 第8行 QString( &quot;field=id:integer&amp;field=name:string(50)&amp;&quot; )是定义的图层字段，这也是我觉得很方便的一个地方，多个字段用&quot;&amp;&quot;进行连接，完整形式为 field=name:type(length,precision)，从参数看不仅可以定义长度还可以定义其精度。 第10行QString( &quot;index=yes&amp;&quot; )是定义空间索引，对于数据量较大的图层很有用。 第11行QString( &quot;memoryid=%1&quot; ).arg( QUuid::createUuid().toString() )比较有趣，它通过QUuid创建了一个全局唯一标识符（UUID），Qt中解释主要是用于分布式计算环境中的实体标识，而此处是用于当我们多次创建临时图层时的唯一标识符。 第3-5行就是一个URL形式字符串的完整展示，包含上述的所有内容，最后{}中一串数字就是通过QUuid自动创建的标识。虽然我没有尝试过，但是应该除了几何类型必须要定义以外，其他的都是可选项，当然如果我们采用这种方式肯定不仅仅是定义一个图层的几何类型而已。 上面准备工作说了很多，第13行才真正创建临时图层：QgsVectorLayer* newLayer = new QgsVectorLayer( layerProperties, QString( &quot;临时点层&quot; ), QString( &quot;memory&quot; ) ) QgsVectorLayer类有3个参数，第1个参数就是URL形式的字符串layerProperties，另外经常用的一种很简单的方式就是直接定义其图层的几何类型即可，如Point；第2个参数是图层的名称；第3个参数是创建图层的类型，这里传入的memory代表创建的是一个临时图层。 将图层添加到地图画布中 第21、23行将才创建的图层添加到地图画布中，并且获得一个QgsVectorDataProvider指针，该指针在后面会用到。 创建几何要素 第25-32行创建了两个点要素来展示结果，网上的很多例子为了让大家更清楚，是分开写的，我这个比较省事：MyFeature.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4443, 32.2123)) ) 使用setGeometry()设置了要素的几何体后，就继续用setAttributes()写入属性，属性类型、顺序与上面我们创建的是一致的，setAttributes()的参数是QgsAttributes对象，而QgsAttributes其实就是QVector&lt;QVariant&gt;，所用我下面代码中是添加的QVariant对象。MyFeature.setAttributes(QgsAttributes() &lt;&lt; QVariant(1) &lt;&lt; QVariant(&quot;test&quot;)) 通过上面的两行代码就成功创建了几何要素并设置了它的属性。 添加几何要素到矢量图层中 第34-41行我们利用上面获得的QgsVectorDataProvider指针将几何要素添加到了矢量图层中，我们先使用startEditing()来使图层可编辑，然后使用commitChanges()来提交改变结果。 刷新 最后更新图层范围，并刷新画布就OK了。 在这里多说一句，如果你按照此方法运行后，在地图画布上不能正常显示，检查下画布是否没有解冻，就是：mapCanvas()-&gt;freeze( false ) 我之前在这吃了亏，由于才接触QGis开发不久，我在程序的其他地方将画布冻结了，导致图层不能正常显示，自己捣鼓了很多次才发现。 效果图 QGis开发只是本人业余爱好，尽量将自己的一点学习心得与大家分享，如在上述内容中有不正确的地方，或有可以改进的地方欢迎大家指正。 本文出自蛋炒饭的博客 http://yoursite.com/2017/09/10/利用C-进行QGis开发之-创建临时图层并添加要素/ 欢迎转载，转载请注明出处！]]></content>
      <categories>
        <category>QGis</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>QGis</tag>
        <tag>二次开发</tag>
        <tag>创建临时图层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt中QScrollArea类的简单使用心得]]></title>
    <url>%2F2017%2F09%2F03%2FQt%E4%B8%ADQScrollArea%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[简要说明如何在QScrollArea滚动窗口中添加多个QWidget的使用方法。 根据自己目前的需求简单说下怎么在QScrollArea滚动窗口中实现多个控件的滚动显示，先看看最终效果： 先说一下在QScrollArea滚动窗口中要添加控件要使用QScrollArea::setWidget(QWidget * widget)这个函数，当添加的控件显示范围大于scrollArea则会出现滚动条，但是从名字可以看出这个函数是用于设置一个QWidget，而不能用于不断的添加QWidget，所以这里面并不能像大家想的那样来直接实现上面的效果，而是需要创建一个自己的QWidget，再在其中来添加自己需要的控件。 下面给出代码看看，由于我的滚动窗口是已经用设计器添加到对话框上的，所以我直接用ui-&gt;scrollArea来调用，buttonListWidget是我重新实现的QWidget子类，等会在下面可以看到实现代码：123buttonListWidget *buttonList = new buttonListWidget(this);buttonList-&gt;initWidget(strList);ui-&gt;scrollArea-&gt;setWidget(buttonList); buttonListWidget类，其实内容不多，但是主要是掌握到方法： buttonListWidget.h1234567891011class buttonListWidget : public QWidget&#123; Q_OBJECTpublic: explicit buttonListWidget(QWidget *parent = 0); void initWidget(QStringList&amp; nameList);signals:public slots:&#125;; buttonListWidget.cpp12345678910111213141516buttonListWidget::buttonListWidget(QWidget *parent) : QWidget(parent)&#123;&#125;void buttonListWidget::initWidget(QStringList &amp;nameList)&#123; QHBoxLayout *layout = new QHBoxLayout(this); foreach (QString str, nameList) &#123; QPushButton *button = new QPushButton(str, this); button-&gt;setMinimumSize(button-&gt;size()); layout-&gt;addWidget(button); &#125; this-&gt;setLayout(layout);&#125; 本文出自蛋炒饭的博客 http://yoursite.com/2017/09/03/Qt中QScrollArea类的简单使用心得/ 欢迎转载，转载请注明出处！]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QScrollArea</tag>
        <tag>滚动窗口</tag>
        <tag>QWidget</tag>
      </tags>
  </entry>
</search>
