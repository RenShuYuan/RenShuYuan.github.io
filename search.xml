<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[putty详细使用说明]]></title>
    <url>%2F2017%2F09%2F17%2Fputty%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[转载于:Leo Chinhttp://www.cnblogs.com/hnrainll/ 在windows下操作linux命令的小工具，非常好。偶然发现，储存资料备用。 PuTTY 是一个跨平台的远程登录工具，包含了一组程序，包括： PuTTY (Telnet 和 SSH 客户端)PSCP (SCP 客户端, 命令行下通过 SSH 拷贝文件，类似于 Unix/Linux 下的 scp 命令)PSFTP (SFTP 的命令行客户端，类似于 FTP 的文件传输，只不过使用的是 SSH 的 22 端口，而非 FTP 的 21 端口，类似于 Unix/Linux 下的 sftp 命令)PuTTYtel (仅仅是一个 Telnet 客户端)Plink (命令行工具，执行远程服务器上的命令)Pageant (PuTTY、PSCP、Plink 的 SSH 认证代理，用这个可以不用每次都输入口令了)PuTTYgen (用来生成 RSA 和 DSA 密钥的工具).虽然包含了这么多，但平时经常见到只是用 PuTTY 登录服务器，完全没有发挥出 PuTTY 的强大功能。PuTTY 作为一个组件也存在于很多的软件中，比如 FileZilla、WinSCP在后面的文字中，如非特别说明，默认的登录的协议是 SSH。毕竟用 PuTTY 主要就是登录 SSH 主机，用 Telnet、RLogin 没法体现出 PuTTY 的强大功能。 [TOC] 安装PuTTY 是一个准绿色软件，说它绿色是因为直接就能使用，完全没有任何的安装程序。准绿色是指 PuTTY 的所有配置都保存到了注册表，如果不记得备份注册表中的相关内容，下次重装机器所有配置就没了，而且配置也不方便用闪存盘随身携带。但是 PuTTY 的配置删除还是蛮方便的，运行时指定个参数 -cleanup 就可以清除 PuTTY 的所有配置信息。 第一印象，开始登录一台远程主机运行 PuTTY 就可以看到下面这个界面 在这里输入服务器的 IP 或主机名，选择好登录协议，还有协议的端口，如果希望把这次的输入保存起来，以后就不需要再重新输入了，就在第4步输入好会话保存的名称，比如：mail-server，或者干脆就是主机的地址，点击保存就可以了 现在问题是： 我的软件是汉化过的（可以从网上找非常小的，只有540多K），但是命令提示信息却是乱码，网上一般的解决办法是针对英文版本如果显示中文字符的。现在招到了一半办法，记录如下，做个资料备份： echo $LANG $LANGUAGE查看linux系统的字符集原来系统的字符集是 UTF-8 呀。重新返回上面选择字符集的那一步， 选择配置窗口左边的 Translation，在右边的 Received data assumed to be in which character set 下拉列表中选择“UTF-8” 这下99%的情形下，汉字是不会有乱码了。最后，总之一下 PuTTY 中乱码的解决办法：先看看系统的字符集，如果是 UTF-8 的，那就简单了，选择好中文字体，然后编码选择 UTF-8 就行了。如果编码是 GB2312、GBK、GB18030，当然也包括 BIG5这些，在 PuTTY 的编码选择中看不到这些编码，那就选择最后一个“Use font encoding”，绝大部分情况下这样就没啥问题了，反正我是没碰到有什么例外的情况。现 在的 Linux 如果默认语言选择为中文，默认的编码就是 UTF-8 了。以前安装 Redhat AS 3 时，语言选择为中文，默认的编码是 zh_CN.gb2312, zh_CN.gb18030，好像从 AS 3 update 6 开始，包括现在的 AS4、AS5，中文的默认编码都成了 zh_CN.utf8。至于 Debian、Ubuntu 等等这些上面，好像一直都是 UTF-8。至于是使用 UTF-8呢，还是用 GB2312、GBK 或者 GB18030呢？我个人还是倾向于 UTF-8。毕竟我们使用的大多数软件都是国外的，处理中文编码多多少少有些问题，PuTTY 自然也不例外。下面的这个图上，我把终端编码修改为 zh_CN.utf8，然后也按照前面的所说的方法把 PuTTY 的字符集修改为 UTF-8。然后在终端中输入汉字“柴锋”，按左方向键，可以看到汉字显示很正常。 我重新把终端的编码修改为 zh_CN.gb2312，同样的，把 PuTTY 的字符集修改为最后一个“Use font encoding”。还是在终端上输入汉字“柴锋”，按下左方向键以后，会看到汉字乱码了。 至 于用哪个编码，主要还是看领导的决定了，我们的领导就喜欢 GBK，连 GB18030 都不行。以前在用 Debian 的时候，好像默认都不支持 GBK 编码。这几年公司的开发在汉字编码问题上出过几次麻烦，还不就是在 ISO8859-1, GB2312/GBK/GB18030和UTF-8上折腾来折腾去。给大家看一张 emacs 的截图，看看上面的这么多语言的文字共同显示，这个会是用 GB2312/GBK/GB18030 的编码么？ 用 UTF-8 也不是为了要在一个屏幕上显示好几种不认识的文字，也不一定非要是跟国际接轨弄个外包给老外开发程序做个其他语言的界面让老外用，起码不要在那么多编码里折腾了，顶多两个 ISO8859-1 和 UTF-8。发发牢骚，下面继续…… 在 PuTTY 里面怎样选中，复制和粘贴？在 PuTTY 的窗口里面复制、粘贴可不能用 Windows 里的这些 Ctrl+C, Ctrl+Ins, Ctrl+V 这些快捷键，Ctrl+C 在控制台上可是终止当前的命令执行。PuTTY 的选择、复制、粘贴这些操作都是通过鼠标来完成的。在 Window-〉Selection 这里可以设置复制和粘贴的方式。 默 认的 Action of mouse buttons （鼠标按键的功能）的选项是 Compromise，这种方式下选中有两种方式，一是直接用鼠标左键拖拉选中就可以了，二是用鼠标中键单击选中区域的开头，用滚动条拖拉到期望选中区域 的末尾，再用鼠标中键单击，就可以选中了。选中以后，单击鼠标左键就把选中部分复制到剪贴板了。粘贴也很简单，单击鼠标右键。Action of mouse buttons 的第一个选项是 Windows （Windows 方式的），鼠标中键的操作跟前面提到的一样。右键不是粘贴了，而是打开了右键菜单。 其实这个右键菜单在标题栏上点击，也都可以看得到。 第三个选项是 xterm （xterm 方式），这个跟默认的 Compromise 方式相反的，中键和右键的操作调换了一下，就不多说了。下 面那个 Shift overrides application’s use of mouse 是和 Shift 键有关的。有些 Rogue Like 的程序，比如 mc、links、Lynx、VIM 等等，都支持鼠标操作，想在用鼠标在上面选择或粘贴就不行了。这个选项默认是选中的，在支持鼠标操作的 Rogue Like 界面下，按住 Shift 键，就可以像前面的那样用鼠标来选择、复制、粘贴了。看下面的这个图片，用 Links 打开了 Google 的首页，用鼠标去选中 顶部中间的 Google，我们会发现，弹出了保存的对话框。 按住 Shift 键重新操作一次，哈哈，这次选中了。 在 Control use of mouse 里面还有个 Default selection mode （默认的选择模式），默认是 Normal，就像文字处理工具里这样的选择 另外一个是 Rectangular block（块选择方式），至于用哪种方式就看自己的选择了。 实时保存会话这次更改配置参数了，关闭窗口后，下次使用还是要重新选择的，麻烦。还是回到上面修改配置的哪个地方，选择左边的 Session，在右边选择要覆盖的会话名称，或者重新输入一个新的名称，点击 Save 按钮保存。 关于注销登录的一些事情成功登录主机后，也能正常看到中文了。这样，我们就可以完成大部分的工作。最后要关闭窗口了，该怎么办呢？我见过很多人，包括我们公司负责专职维护的同事，都是直接点击窗口上的关闭按钮，完全没有理会弹出警告窗口，直接点击了 Yes。 这样做是不对的，首先这不是正确的注销方式，应该输入命令 exit 来正常注销； 其次直接关闭窗口后，你的登录其实还在服务器上，如果一连多次的这样强制关闭窗口，用命令 w 或者 who 命令查看时，可以看到很多的用户还在系统上登录，占用了系统的资源。最重要的是，你的这次登录可能只是为了启动一下 WebLogic 或者其他什么应用服务器，直接关闭窗口后，可能会导致你的业务在随后的几分钟内也被终止，这应该不是你所希望看到的吧。如果上述的理由是每次要输入 exit 然后回车，比较麻烦。你可以用快捷键 Ctrl+d 来注销登录，一般情况下，快捷键一按窗口都直接关闭了，还省了两次鼠标点击。在前面说道保存会话时，大家或许也注意到，下面有个 Close window on exit 有三个选项： Always （不管怎样，窗口总是要关闭的） Never （无论是否有程序还在运行，都不要关闭窗口） Only on clear exit （这个是默认选中的，只有在本次登录中运行的程序都正常终止或者在后台运行，窗口才关闭）有的程序在执行时，虽然在命令最后面加上 “&amp;”就能放到后台运行。但是正常注销登录后，窗口没有被自动关闭，还能看到程序的输出，这时强制关闭窗口还是可以的。为了避免这种情形，可以使用 nohup 命令。用法嘛就是： nohup 命令 命令参数，这样就可以了。 窗口保存的输出有点少，前面的都看不到了执行了一个命令，输出了好多东西，但是默认的配置下，PuTTY只保存了最后200行的内容，满足不了我们的需求。还是在标题栏上点右键选择 Change settings…，在配置窗口的左边选择 Window，修改右边的 Lines of scrollback，改大点，比如 20000、80000的 在上面的 Set the size of the window 里设置的是窗口显示的行数和列数，默认是 24 行、80 列，根据自己的需要来修改吧。When window is resized 这个选项配置的是，当窗口大小发生改变时该采取什么动作。 Change the number of rows and columns（这个是默认的，改变窗口大小时，自动修改行数和列数）Change the size of the font（这个是根据窗口的大小来修改字体的大小，窗口最大化的时候，字都是很大的）Change font size only when maximised（只有在窗口最大化的时候才改变字体大小）Forbid resizing completely（完全禁止改变窗口大小，一了百了）在现代的 Unix/Linux 主机上，默认选项已经不存在任何问题了。如果是 Solaris 8 这样的老式 Unix 上最好用第2或第4个选项。第3个选项嘛，要求你的屏幕不是宽屏的，选中这个选项以后，大家可以先把窗口往窄的缩一下，然后最大化窗口，哈哈，满足一下不是宽屏的虚荣心。顺便说一下，在 PuTTY 中的前后翻页，与 Linux 终端一样，用 Shift+PageUp/PageDown 来上下翻页，而 Ctrl+PageUp/PageDown 则是一行一行的。 新建一个会话时，还有些东西再啰嗦一下前面把如何用 PuTTY 登录一台主机到注销的过程聊了一遍，但是在新建会话时还是有些东西需要再啰嗦一下的。 保持连接，不要自动断开在 Connection 里面有个 Seconds between keepaliaves，这里就是每间隔指定的秒数，就给服务器发送一个空的数据包，来保持连接。以免登录的主机那边在长时间没接到数据后，会自动断开 SSH 的连接。默认输入 0 是禁用保持连接，在这里我习惯的设置了 10。下面的那两个复选框都保持默认选中吧。 自动登录用户在 Connection-〉Data 里面有个 Auto-login username，可以指定默认的登录用户。如果每次登录主机都是用同一个用户，不妨在这里设置一下。SSH、Telnet、Rlogin 这三种协议都支持，但不是所有的 Telnet 服务器支持自动登录用户 自动设置环境变量还是前面的那个界面，下面有个 Environment variables，在 Variable 输入环境变量的名称，Value里设置上环境变量的值，登录主机后就会自动设置上，但是这个不一定能用，有些主机为了安全，可能会禁用这个特性，一旦登录 就会收到这样一个错误提示： Server refused to set environment variables 设置代理服务器这个经常用到，设置方法大同小异，注意选择好 Proxy type（代理服务器的类型）就可以了。代理服务器的地址填写到 Proxy hostname 这里，Port 就是代理服务的端口（HTTP代理常用端口有 3128、8080，Socks5代理常用端口有 1080）Exclude Hosts/IPs 这里是填写排除的主机地址和IP，有些地址不需要代理，就在这里填写。有些代理需要认证，用户名填写到 Username，密码则填写到下面的 Password。 自动执行一个命令在 Connection-〉SSH 里有个 Remote command，在这里面填写上远程服务器上的某个命令，比如：df，登录后就会自动执行。我们在 Unix 上用 ssh 登录主机时用的命令 ssh，在 ssh 的最后面加上远程主机上的命令，就跟这个一样。但是……，先别着急，一旦设置上这个选项，你会发现在登录成功后，窗口一下就关闭了，嘿，怎么啦？什么也没看见。因为命令执行完毕的同时，本次 SSH 登录连接也随之关闭。 你可以把远程自动执行的命令修改成 sleep 10，然后重新登录，再看看效果。登录成功后，没有出现命令提示符，10秒钟后，窗口自动关闭。这也验证了刚才我说的，命令执行完毕后，SSH 连接自动断开。冰雪聪明的你一定会想到，如果每次登录主机，都是要重新启动一下 tomcat，那这里就可以填写上这样的命令： export CATALINA_HOME=&quot;~/apache-tomcat-5.5.17&quot;;export JAVA_HOME=&quot;~/jdk1.5.0_07&quot;;export PATH=$JAVA_HOME/bin;$PATH ; cd $CATALINA_HOME/bin;./shutdown.sh;./startup.sh;tail -f $CATALINA_HOME/logs/catalina.out（上面的命令是一行的哦）先自动设置一下环境变量（前面有提到，服务器可能会禁用自动设置环境变量，为了保险起见，在这里设置了一下），然 后进入 tomcat 的 bin 目录，用 shutdown.sh 停止 tomcat，然后再 startup.sh 启动 tomcat，最后 tail 命令持续观察 tomcat 的日志输出，不想看了，就直接 Ctrl+C 就可以终止 SSH 的会话了。哈哈，是不是很方便？不 过前面提到的命令 sleep 10，只是建立了 SSH 连接，然后 10 秒钟后自动断开。是不是觉得很无聊没什么用途啊？其实这个命令配合后面提到的 Tunnels（隧道），可以自动保持隧道一定时间的开放，如果指定时间内（在这里就是 10 秒钟）隧道没有被使用，就自动关闭 SSH 连接和隧道。如 果选中了 Don’t start a shell or command at all 就禁用了自动执行命令这一个特性，这个主要是配合 Tunnels （隧道）来使用的。因为有时候，我们只需要利用隧道建立一个 VPN，而并不需要登录上去执行命令。用这个方法建立好隧道以后，就一直开放了，除非自己手工关闭。 嗯，还有个问题哦，如果一次要执行的命令很多，该怎么办呢？嗯，给 PuTTY 用 -m 选项指定一个包含远程主机上执行的命令的文本文件。不过以后还会说到 Plink，就是专门做这个用的，慢慢来慢慢来。 数据自动压缩传输，变相的提高传输速率还是前面的那个界面，Protocol options 里面有个 Enable compression，这个选项的意思就是传输时压缩数据，在连接速度不变的情况下，变相的提高了传输速率。一般的 SSH 服务器都会允许这个选项的，所以还是选中好了。 无需口令登录在 Connection-〉SSH-〉Auth 这里面有两个需要了解的，以后在讲到 PuTTYGEN 和 Pagent 时会详细介绍的。一个是 Allow agent forwarding，作用是允许私钥代理的转发。另外一个是最下面的 Private key file for authentication，选择私钥认证文件。这 两个可以让你用 SSH 登录不用输入主机口令，但是私钥的口令还是需要输入的，如果使用了私钥代理 Pagent ，私钥口令也可以省略。再配合前面提到的自动指定用户名登录，可以实现自动登录主机。登录到主机上以后，用 SSH 登录另外一个同样配置了相同的私钥认证的主机，也可以不用再次输入口令。这些可以大大减轻了我们的重复工作，不用单调枯燥的输入用户名和口令，但是这样使用有个后遗症就是如果主机密码没有在另外一个地方记录下来的话，这个密码很快会忘记的，好处嘛，密码可以设置的很长很变态 XD。 X11 转发能够让你在 Windows 上使用 Linux 的程序这里很简单，选中 Enable X11 forwarding 后登录主机，记得在我们本地运行 X 服务端程序（比如：免费好用的 Xming）。 然后在控制台直接输入 X 环境下运行的程序，比如：xlogo，我们就可以看到 Linux 上的GUI界面的程序在Windows桌面上打开了。 运行个复杂的，比如 gnome-session，这个是 GNOME 的启动命令，如果想打开 KDE 就是 startkde 这样跟在本地使用 X Window 几乎是一样的了，而且还是运行在 Windows 的桌面上呢，骗骗小 mm 还是不错的。或许你会问这样用跟 vnc 那还不一样了？答案是，不一样。如果网络环境不好，还是用vnc吧，否则迟钝的图形响应速度会让你抓狂的。打开了 GNOME 桌面，怎么关闭呢？点菜单的注销吧。如果你点了关机，这可关不了你的Windows，关的是远程主机。 用 SSH Tunnels（SSH 隧道），突破防火墙哇哦，突破防火墙！是不是忽然有了做黑客的感觉呢？呀！子弹，我躲——，身子往后仰，继续闪……，噢，肚皮被子弹蹭了一下。简单的说一下，SSH 协议能够通过已经建立好的 SSH 加密链路来转发任意的网络连接，从而避免了网络中的明文传输，也就无法用一些 Sniffer 工具嗅探到我们的隐秘信息了。先 说一下大致的使用过程，登录到主机上以后，就可以建立好一个 SSH 隧道，这时在你的机器本地会开放一个端口，通过本地的这个端口访问，就相当于在主机上去直接访问。很像代理服务器吧，如果隧道另一端的端口是动态 的，SSH 隧道就是一个代理了，SSH 隧道的意思大致就是这个。通过 SSH 隧道，我们可以保证从我们这一段到主机那一端是安全的，不会被监听到。说了这么多，实际演练演练就知道了。在 PuTTY 的 Connection-〉SSH-〉Tunnels 这里就是配置 SSH 隧道的。Add new forwarded port 这里就是添加隧道转发端口的，其中 Source port 是隧道的源端口，也就是隧道的入口，连接隧道时要连接这个端口。Destination 这里是目的地，隧道的出口，输入的格式是： server:port。还 要说明的一点是 SSH 隧道是有方向的，这个方向是由下面的单选按钮 Local/Remote/Dynamic 来决定的。如果下面的单选按钮选中的是 Local，那么 Destination 这里填写的目标是相对于远程主机而言，而非你的机器。这样的隧道可以称之为正向隧道，隧道的入口是在你的本地，出口在远程主机那一端。如果单选按钮选中的 是 Remote，那么目标地址就是相对与你的机器而言，而非远程主机。这样的隧道称之为反向隧道，隧道的入口是远程主机那一端，隧道的出口则是你的本地机 器。这与 Local 选项是相反的。而最后一个 Dynamic 则不用指明 Destination 目标地址，也就是说目标地址是动态的了，连入隧道时可以随意指定目标地址，而不像 Local/Remote 指明的固定目标地址，所以这样的隧道就成了变相的加密 socks5 代理服务器了。看明白了么？是不是会有些糊涂？后面我会举个例子来详细说说的。 开 始演练，我们现在建立一条到远程主机 guantouping 上端口 7001 的隧道，在 guantouping 上可以用 nc -l -p 7001 localhost 这条命令建立一个监听本地到端口 7001 的连接，这样确保无法从其他机器访问这台主机的端口，只能在 guantouping 这台主机上用 telnet localhost 7001 来连接。现在我的机器 IP 是 192.168.6.25，如果直接用命令 telnet guantouping 7001 访问的话，那么在主机 guantouping 上会看到这样的提示：12[taylor@guantouping taylor]$ nc -l -p 7001 localhostinvalid connection to [192.168.6.200] from (UNKNOWN) [192.168.6.25] 1926 在这个配置面板上， Source port 上填写 8080，也就是我们要通过本地的 8080 端口来进入 SSH 隧道，Destination 这里填上 127.0.0.1:7001，就表示被登录的主机 guantouping 访问该主机本地的 127.0.0.1:7001 这个端口。正常登录到主机 guantouping 以后，SSH 隧道就建立好了。在我的机器 192.168.6.25 上输入命令 telnet localhost 8080，输入一些东西，就会在 guantouping 上看到有响应。在这里我用的是 nc，看起来方便一点，telnet 也是一样的。 这就是正向 SSH 隧道的一个例子，大家实地操作几次也就会明白了。最上面有个复选框是“Local ports accept connections from other hosts”，这个选项的作用是允许其他主机连接你机器上的隧道入口，默认情况下建立好隧道以后，只允许本地链接。只有选中这个复选框才允许其他主机连接 你的本地隧道入口。 象特洛伊木马一样建立一条 SSH 反向隧道下面要说的就是选中单选按钮 Remote 后建立的反向 SSH 隧道，这样的隧道做什么用呢？一般防火墙都是允许从内往外链接，而不允许从外到内的链接，除非在防火墙上做好nat或端口转发。现在，你在防火墙的内部， 但是又想让外面的人链接到你的机器上。防火墙厚厚的城门紧闭，外面的人进不来，只有你能从里面打开这扇防护严密的大门，就像一个特洛伊木马一样，你主动连 接出去建立一个反向的 SSH 隧道，然后外面的人就可以通过这个反向的 SSH 隧道轻松突破防火墙链接到的你的本地机器。看下面这个图： 在 Source port 这里填写 8080，也就是隧道的入口是端口8080，Destination 这里填写 localhost:7001，也就是隧道的出口是本地的 7001 端口，下面的单选按钮要选中 Remote，表示建立的隧道是个反向隧道，填写完毕别忘记点 Add 按钮，在上面就可以看到显示的是 R8080 localhost:7001。成功登录远程主机 guantouping 后，反向隧道就建立好了。在远程主机 guantouping 上输入命令 telnet localhost 8080 就可以连接到你的本地端口7001。 哈哈，这样一个特洛伊木马般的反向 SSH 隧道就建立完毕了。我们在远程主机上连接 8080 端口，其实就连接到了我们本地机器的7001 端口了。上面共有两个复选框，我们提到了一个，已经说了，选中以后就允许其他机器连接隧道入口了。那第二个“Remote ports do the same (SSH-2 only)”，则是给反向隧道使用的，也就是说远程主机的那个反响隧道入口也做同样的事情，也就是允许其他机器连接远程主机上的反向隧道入口，不过一般情 况下这个选项都不会起作用的 ^_^。 把 PuTTY 作为一个安全的代理服务器来使用这个简单，在 Source port 那里填写上 1080，Destination 这里空下不填，选中下面的 Dynamic，最后别忘了点 Add 按钮。 登录远程主机后，一个代理服务器就建立好了，这个代理服务器的地址就是 localhost:1080，还是加密的哦。据说国外某著名的主机供应商就提供远程的 SSH 链接，通过这个方法我们就建立了一个加密的 socks5 代理，可以轻松绕过万恶的 GFW 去拥抱 Wikipedia，波～～～，来一口。 设置 PuTTY 的默认设置每次登录主机，无一例外的修改字体，修改字符集，修改窗口的大小，指定私钥文件，允许 X11 转发，……几台主机还好说，几十个上百个主机这样三天两头的设置也会让唐僧烦了的。选中一个先前配置好的会话，点 Load 按钮。 然后修改Saved Sessions会话名称 和 Host Name 这里的主机地址，点Save 如果在 Saved Sessions 这里和上面的 Host Name 清空，点 Save 按钮，就可以把设置保存为默认设置。 备份 PuTTY 的设置用 PuTTY 最不爽的就是，它把所有的设置都保存到注册表了，本来这不是什么问题。但是难免会重装一下机器，用下面的命令可以备份 PuTTY 的所有设置 regedit /e PuTTY.config.reg &quot;HKEY_CURRENT_USER\Software\SimonTatham\PuTTY&quot; 删除 PuTTY 的设置如果只是在其他机器上临时用了一个 PuTTY，用完以后想删除 PuTTY 的配置，就在控制台里输入如下的命令： putty.exe -cleanup 用 PuTTYgen 来生成密钥，以后可以不用密码登录服务器了PuTTYgen 是密钥生成器，用来生成一对公钥和私钥供 PuTTY、PSCP、Plink、Pagent 来使用。直接运行 PuTTYgen 可以看到如下的界面。 点击 Generate 按钮就开始生成一个公钥和私钥对，生成完毕后，点下面的 Save private key 就可以把私钥保存起来，扩展名是 .ppk 的文件。Load 按钮可以把先前保存的私钥重新打开，然后做些修改，比如修改注释和私钥口令，或者把 PuTTY 格式的私钥转换为 OpenSSH 格式的。 开始用 PuTTYgen 创建密钥单击 Generate 按钮，然后你会看到进度条上面有个提示“Please generate some radomness by moving the mouse over the blank area.”，意思就是让你用鼠标在空白区域随机移动。随着鼠标在空白区域的移动，进度条会一直走下去。停止移动鼠标，进度条也就停止了。那我们就移动鼠 标，直到进度条走满为止。 等进度条走完之后，会出现下面的界面 最上面那个大大的只读文本框里面是公钥，用来保存到 OpenSSH 的 authorized_keys 文件中，这个文件中的每一行都是一个公钥。默认情况下，这个文件位于 Linux 用户主目录的 .ssh/ 子目录中，如果文件和目录都不存在，可以直接创建。但 是创建的文件、目录和用户主目录（$HOME, $HOME/.ssh, $HOME/.ssh/authorized_keys）的权限有个限制就是对除了本帐户的其他所有帐户都要求是只读的，否则的话，即使公钥、私钥都匹配 无误，也是无法登入系统的。这是 SSH 服务器的一个安全要求，因为如果别的帐户可以修改你的 authorized_keys 的话，恶意的增加一个公钥，那对方不用你的帐户口令也能以你的帐户登入系统了。对于一些特殊要求，你可以在 SSH 服务器的配置文件 sshd_config 中用指令 StrictModes no来取消这个限制。在 sshd_config 的帮助手册中可以看到 StrictModes Specifies whether sshd should check file modes and ownership of the user’s files and home directory before accepting login. This is normally desirable because novices sometimes accidentally leave their directory or files world-writable. The default is “yes”. 小技巧：每次修改 authorized_keys 这个文件时，你可以用如下的命令来修改，确保所有的文件属性和权限无误12mkdir -p $HOME/.ssh &amp;&amp; touch $HOME/.ssh/authorized_keys \&amp;&amp; chmod go-w $HOME $HOME/.ssh $HOME/.ssh/authorized_keys &amp;&amp; vim $HOME/.ssh/authorized_keys 还有一个要强调的是那个 Key comment，这是密钥的注释，一定要修改。因为这个密钥是给自己用的，所以最起码要输入自己的名字，用默认的注释很容易和其他人的密钥混淆的。如果担 心自己的密码忘记了，可以在后面加上密码提示，当然了，不要让别人用注释猜出你的密钥口令。比如，我可以把注释修改为 ChaiFeng [20061120] w.z.后面的 w.z. 就是我的密码提示，能猜出来么？呵呵 输入注释，上面的公钥也会随之发生变化。现在最重要的是，输入自己的密钥口令。就是 Key passphrase 和 Confirm passphrase 这个两个输入框。如果不输入口令，直接保存私钥会看到这个提示。为了安全起见还是输入口令吧，要不任何人得到这个私钥都可以不用口令登入系统了。 最后单击 Save private key 来保存私钥吧，保存到自己认为安全的地方，比如存放到私人的 USB 闪存盘上。需要登录时，插上 USB 闪存盘。登录完毕后就可以把 USB 闪存盘取下来，哈哈，这样子就比较安全了。大 家也注意到了，还有个 Save public key 按钮，这个是保存 SSH2 格式的公钥，有些 SSH 服务器要求用这种格式的公钥文件。一般情况下，我们是不需要的，所以这里也就保存了。以后还想的话，就用 PuTTYgen 把私钥 Load 出来，然后再保存也可以。 用密钥登录服务器的流程上面杂七杂八的说了一堆创建密钥时的事情，大家会不会已经有些乱了呢？我把这个过程再罗列一遍： 如果没有公钥/密钥对，就用 PuTTYgen 创建一个，已经有了就可以忽略这一步。一个公钥/密钥对可以用在不同的服务器上，所以也不需要重复创建，关键要有足够强健的密码和安全的存放。象先前一样输入帐户名和口令登录到主机上。输入如下命令，来编辑 authorized_keys 文件1mkdir -p $HOME/.ssh &amp;&amp; touch $HOME/.ssh/authorized_keys \&amp;&amp; chmod go-w $HOME $HOME/.ssh $HOME/.ssh/authorized_keys &amp;&amp; vim $HOME/.ssh/authorized_keys 把这个文本框里的公钥粘贴到 vim 中去，需要说明几点：这个文本框里的内容是一行的，粘贴到 vim 中时，别忘了按字母 o 这个键，否则的话，粘贴进去后，开头的 ssh-rsa 会变成 sh-rsa，为什么呢？哈哈，想想吧。为什么不按字母键 i 呢？这个在 vim 中不就是插入么？原因是我很懒，按字母 o，我可以节省一次按回车键。虽然按大写 O 也行，那我不是还得再按一下 Shift 键么？别 忘了，在 PuTTY 中默认的粘贴可是按鼠标右键哦，然后按一下 ESC 键，然后输入 :wq 保存退出，等等，大家先别着急的输入 :wq，既然输入冒号还得按下 Shift 键，那我们就干脆直接两下大写的字母 Z，也就是 ZZ。怎么样？vim 也一样保存退出了吧。这次又节省了一次按键和两次寻找字母的移动，把懒得优良传统再一次在实践中发扬光大。 如果已经有了私钥，第4步里的那个公钥忘记保存了，就用 PuTTYgen 把这个私钥 Load 上去，然后重新复制一下公钥吧。在 PuTTY 的配置 Connection-&gt;SSH-&gt;Auth 这里面，指定上私钥，然后记得保存 Session，以后就不需要重复这一步了。 最好也指定上自动登录的用户名，还记得这里吗？ 开始登录吧，这次你会看到一个不同于以往的登录提示现 在输入的口令可不是主机上这个账户的口令了，而是先前创建的这个密钥的口令。以后不管这个账户的口令是什么，即使再复杂，也和我们没关系了。只要这个账户 的 $HOME/.ssh/authorized_keys 文件中，有我们的公钥，我们就随时用匹配的私钥都可以登录了。配合后面提到的 Pagent，我们连输入密钥口令这一步也可以忽略过去。 登录成功了，别忘了按 Ctrl+d 注销哦。 以后这些步骤就不需要再重复了，只需要打开 PuTTY 后，双击一下保存的会话名称，输入密钥口令。 Pagent 加载密钥，每次开机后只需要输入一次密钥口令终于轮到 Pagent 出场了，双击一下 Pagent.exe，嗯，没反应？再双击一下，咦？出来个提示，说已经运行了。 看看右下角吧，在这里呢 双击一下 Pagent 的图标，出来这样一个界面。很简洁的，Add Key 是添加私钥，Remove Key 是把选中的私钥从 Pagent 中卸载了。 好，现在单击 Add Key 按钮添加私钥，我把这个演示用的私钥保存到 C:\ 了 然后会出现输入密钥口令的对话框，输入正确的密钥后，单击 OK 这时，在 Pagent 的窗口中就能看到我们的私钥已经装载上去了。 现在打开 PuTTY，选择先前保存的 Session，双击一下。只要自动登录用户名设置上，主机上改帐户的 authorized_keys 文件里也有匹配的公钥。哈哈，发现没有？完全不需要口令，我们已经登录到系统了。在 Pagent 的图标上点右键，也可以快捷的选择已经保存的会话。 建 议大家把 Pagent 放到启动组里面，这样每次一开机，Pagent 自动运行，然后我们只需要把私钥装载一下，然后我们就可以一直享受自动登录系统的乐趣了。再配合上以后会讲到的 Plink、PSCP 这些，我们可以实现很多工作的自动化进行。完全不需要每次输入用户名、口令、输入又长又多的命令，再做一些烦躁的文件备份，最后还得记得注销系统，难道不 觉得麻烦么？这一切烦恼很快就会远离我们了，继续往下看吧。 用 SSH 来传输文件PuTTY 提供了两个文件传输工具 PSCP (PuTTY Secure Copy client) PSFTP (PuTTY SFTP client)PSCP 通过 SSH 连接，在两台机器之间安全的传输文件，可以用于任何 SSH（包括 SSH v1、SSH v2） 服务器。PSFTP 则是 SSH-2 中新增的特性，使用的是新的 SFTP 协议，使用上与传统的 FTP 类似。事实上 PSCP 如果发现 SFTP 可用，PSCP就会使用 SFTP 协议来传输文件，否则还是 SCP 协议。PSFTP 与 PSCP 相比，PSFTP 的优点是可以与服务器进行交互，遍历服务器上的文件系统，在一个会话中上传或下载多个文件。而 PSCP 只能一次传输一个文件，传输完毕后立刻终止会话。 PSCP 的使用在控制台直接执行 pscp 可以看到帮助123456789101112131415161718192021222324252627C:\&gt;pscpPuTTY Secure Copy clientRelease 0.58Usage: pscp [options] [user@]host:source target pscp [options] source [source...] [user@]host:target pscp [options] -ls [user@]host:filespecOptions: -V print version information and exit -pgpfp print PGP key fingerprints and exit -p preserve file attributes -q quiet, don&apos;t show statistics -r copy directories recursively -v show verbose messages -load sessname Load settings from saved session -P port connect to specified port -l user connect with specified username -pw passw login with specified password -1 -2 force use of particular SSH protocol version -4 -6 force use of IPv4 or IPv6 -C enable compression -i key private key file for authentication -batch disable all interactive prompts -unsafe allow server-side wildcards (DANGEROUS) -sftp force use of SFTP protocol -scp force use of SCP protocolC:\&gt; 可以看出 PSCP 的使用是很简单的，把常用的几个选项说一下： -q 安静模式，传输文件时什么也不显示，否则会显示出文件的传输进度，默认是关闭的 -P port 指定服务器的 SSH 端口，注意这个是大写字母 P，默认是 -P 22，如果主机的 SSH 端口就是 22，就不用指定了 -l user 指定以哪个用户的身份登录主机，如果没有指定，则 PSCP 会在 PuTTY 保存的同名 Session 中获得默认的用户名称。用户名称也可以和主机名称写在一起，用 @ 分割开，比如：username@server -pw passwd 指定登录时所用的口令为 passwd -i keyfile 就是指定登录时所用的密钥文件 最后面指定的主机名也可以是 PuTTY 中保存的 Session 名称。比如我们在 PuTTY 中保存了一个名为 foobarserver 的会话，而我们所在的网络又的确没有名为 foobarserver 的主机名称。而在这个 foobarserver 会话中保存的主机名称是 demo-server，保存的自动登录的用户是 taylor。那么用命令 就把本地的 c:\autoexec.bat 复制到了主机 demo-server 上的用户 taylor 所在的主目录下的 backup 子目录中(这个路径可能是 /home/taylor/backup) pscp c:\autoexec.bat foobarserver:backup/所以 PSCP 大致用法的例子就是：pscp -P 22 -i c:\path\your-private-key.ppk -C username@server:/remote/path/下面还是用一些实例来说明会比较简单一些：把本地的 C:\path\foo.txt 复制到远程主机 192.168.6.200 的 /tmp 目录下 pscp c:\path\foo.txt 192.168.6.200:/tmp把本地的 C:\path\foo.txt 复制到主机 192.168.6.200 的 /tmp 目录下，但是以主机上的用户 taylor 的权限执行 pscp c:\path\foo.txt taylor@192.168.6.200:/tmp或者是 pscp -l taylor c:\path\foo.txt 192.168.6.200:/tmp把本地的 C:\path\foo.txt 传送到主机 192.168.6.200 的 /tmp 目录下，但是主机的 SSH 端口是 3122 pscp -P 3122 c:\path\foo.txt 192.168.6.200:/tmp把本地的 C:\path\foo.txt 复制到主机 192.168.6.200 的用户 taylor 的主目录下 pscp c:\path\foo.txt taylor@192.168.6.200:.把主机 192.168.6.200 上的用户 taylor 主目录下的所有 *.tgz 文件拷贝到本地的 c:\backup 目录中，如果 SSH 版本是 SSH v1，那这个命令就会出错。 pscp taylor@192.168.6.200:*.tgz c:\backup 再来看看 PSFTP在控制台执行命令 psftp -h，可以得到 psftp 的帮助 12345678910111213141516171819202122C:\&gt;psftp -hPuTTY Secure File Transfer (SFTP) clientRelease 0.58Usage: psftp [options] [user@]hostOptions: -V print version information and exit -pgpfp print PGP key fingerprints and exit -b file use specified batchfile -bc output batchfile commands -be don&apos;t stop batchfile processing if errors -v show verbose messages -load sessname Load settings from saved session -l user connect with specified username -P port connect to specified port -pw passw login with specified password -1 -2 force use of particular SSH protocol version -4 -6 force use of IPv4 or IPv6 -C enable compression -i key private key file for authentication -batch disable all interactive promptsC:\&gt; 用法与 PSCP 大同小异，虽然有个 -load 选项，其实这个没啥用，后面用主机名的时候，与 PSCP 一样直接用上会话名称就可以了。用 PSFTP 登录到服务器上以后，操作与 FTP 差不多，这里简单的说一下吧： open 登录主机open [username@] [port]比如： open taylor@demo-server 3022就是以用户 taylor 的身份，登陆到主机 demo-server 上，SSH 端口是 3022 open demo-server登陆 demo-server，这里的 demo-server 可以是PuTTY 中已经保存的会话名称，也可以是主机的名称，如果主机名称与会话名称相同，以会话名称为准。 close 关闭 SFTP 连接这个没啥说的，close 就关闭了 SFTP 连接 quit 结束本次的 SFTP 会话也没啥用法，就是关闭了 PSFTP 这个程序 help [command] 帮助直接打 help 就可以看到帮助指令，后面指定上 一个命令就可以查看该命令的帮助，比如： help open cd [directory] 改变当前目录 pwd 察看当前目录 lcd [directory] 改变本地目录 lpwd 察看本地当前目录 get [-r] 从服务器下载一个文件/目录，这个命令不能用通配符，参数 -r 可以递归下载整个目录 put [-r] [dest] 把文件/目录上传到服务器，这个命令不能用通配符，参数 -r 可以递归上传整个目录 mget [-r] 从服务器下载一批文件/目录，可以用通配符，-r 的含义与 get 一样 mget [-r] [dest] 把一批文件/目录上传到服务器，可以用通配符，-r 的含义与 put 一样 reget [-r] 从服务器续传下载一个文件/目录，这个命令不能用通配符，-r 的含义与 get 一样 reput [-r] [dest] 把一批文件/目录续传上传到服务器，这个命令不能用通配符，-r 的含义与 put 一样 dir [directory] 列目录 ls 和 dir 一样 chmod [file|directory] 改变文件的权限，与 Unix 的 chmod 命令类似 del 删除文件，要注意的是 del 只能删除文件 rm 与 del 一样 mkdir 创建一个目录 rmdir 删除一个空目录，只有空目录才可以被删除 mv 改名/移动。如果源和目的都是文件或目录，则是改名。如果目的是目录的话，则是移动。 ! 在本地命令前加一个感叹号，就可以直接执行 其他可选的 SFTP 客户端FileZilla : http://filezilla.sf.net/WinSCP : http://www.winscp.net/ 用 Plink 更方便快捷的执行远程主机上的命令Plink 是 PuTTY 的命令行连接工具，主要用于自动化工作的处理。直接在控制台执行 plink，可以看到 Plink 的帮助1234567891011121314151617181920212223242526272829303132333435C:\&gt;plinkPuTTY Link: command-line connection utilityRelease 0.58Usage: plink [options] [user@]host [command] (&quot;host&quot; can also be a PuTTY saved session name)Options: -V print version information and exit -pgpfp print PGP key fingerprints and exit -v show verbose messages -load sessname Load settings from saved session -ssh -telnet -rlogin -raw force use of a particular protocol -P port connect to specified port -l user connect with specified username -batch disable all interactive promptsThe following options only apply to SSH connections: -pw passw login with specified password -D [listen-IP:]listen-port Dynamic SOCKS-based port forwarding -L [listen-IP:]listen-port:host:port Forward local port to remote address -R [listen-IP:]listen-port:host:port Forward remote port to local address -X -x enable / disable X11 forwarding -A -a enable / disable agent forwarding -t -T enable / disable pty allocation -1 -2 force use of particular protocol version -4 -6 force use of IPv4 or IPv6 -C enable compression -i key private key file for authentication -m file read remote command(s) from file -s remote command is an SSH subsystem (SSH-2 only) -N don&apos;t start a shell/command (SSH-2 only)C:\&gt; 看上去 Plink 的使用方法、参数与PSCP、PSFTP都很类似。 -P port 指定服务器的 SSH 端口，注意这个是大写字母 P，默认是 -P 22，如果主机的 SSH 端口就是 22，就不用指定了 -l user 指定以哪个用户的身份登录主机，如果没有指定，则 PSCP 会在 PuTTY 保存的同名 Session 中获得默认的用户名称。用户名称也可以和主机名称写在一起，用 @ 分割开，比如：username@server -pw passwd 指定登录时所用的口令为 passwd -i keyfile 就是指定登录时所用的密钥文件 -m file 如果执行的命令很多的话，可以把命令写到文件中，然后用这个参数来指定还是用一些实际的例子来说明一下 Plink 吧还记得前面说到 PuTTY 的自动执行命令那个配置么？在说到那个配置的时候，我们演示了一个简单的 Tomcat 重新启动的命令，这个命令是要写在 PuTTY 的 Remote command 里面去。现在我们用 Plink 来实现同样的功能：假设连接的主机是 192.168.6.200，SSH 的端口是 3022，用户是 taylor： plink -P 3022 taylor@192.168.6.200 export CATALINA_HOME=&quot;~/apache-tomcat-5.5.17&quot;;export JAVA_HOME=&quot;~/jdk1.5.0_07&quot;;export PATH=$JAVA_HOME/bin;$PATH ; cd $CATALINA_HOME/bin;./shutdown.sh;./startup.sh;tail -f $CATALINA_HOME/logs/catalina.out如果在 PuTTY 中保存了一个名为 192.168.6.200 的会话，注意，这个会话的名称与主机 IP 一样，在会话中已经正确保存了端口 3022，指定了默认的用户是 taylor，现在这个命令就可以简化为： plink 192.168.6.200 export CATALINA_HOME=&quot;~/apache-tomcat-5.5.17&quot;;export JAVA_HOME=&quot;~/jdk1.5.0_07&quot;;export PATH=$JAVA_HOME/bin;$PATH ; cd $CATALINA_HOME/bin;./shutdown.sh;./startup.sh;tail -f $CATALINA_HOME/logs/catalina.out用 date 命令查看一下主机上的时间，并且格式化输出： plink 192.168.6.200 date &quot;+%F %T&quot;大家实际执行一下命令看看，会发现，这个命令并没有返回我们期望的结果，而是返回了一个错误：123C:\&gt;plink 192.168.6.200 date &quot;+%F %T&quot;date: too many non-option arguments: %TTry `date --help&apos; for more information. 可是在服务器上直接执行命令 date “+%F %T”，的确是正确无误的，哪里出了问题呢？这是因为Windows的控制台会把两个双引号之间的字符串作为一个参数传递给被执行的程序，而不会把双引号也传递给程序。我们做这样一个小小的实验来说明一下这个问题：比 如在 c:\tmp 文件夹里建立三个文件夹，名称分别为：”foo”、”bar”、”foo bar”。然后在 foo 这个文件夹里面建立一个名为“foo.log”的空文件，在“bar”这个文件夹里建立一个名为“bar.log”的空文件，在“foo bar”这个文件夹里建立一个名为“foo-bar.log”的空文件。然后在控制台下进入 c:\tmp 这个文件夹，执行如下命令： dir foo bar结果是列出“foo bar”这个文件夹里的内容，还是分别列出“foo”和“bar”文件夹里的东西呢？正确答案是后者。要想正确列出“foo bar”文件夹里的东西，就需要用双引号把”foo bar”引起来1234567891011121314151617181920212223242526272829303132C:\tmp&gt;dir foo bar Volume in drive C is System Volume Serial Number is 9C51-A51C Directory of C:\tmp\foo2006-11-22 09:48 &lt;DIR&gt; .2006-11-22 09:48 &lt;DIR&gt; ..2006-11-16 11:58 0 foo.log 1 File(s) 0 bytes Directory of C:\tmp\bar2006-11-22 09:48 &lt;DIR&gt; .2006-11-22 09:48 &lt;DIR&gt; ..2006-11-16 11:58 0 bar.log 1 File(s) 0 bytes 2 Dir(s) 1,107,345,408 bytes freeC:\tmp&gt;dir &quot;foo bar&quot; Volume in drive C is System Volume Serial Number is 9C51-A51C Directory of C:\tmp\foo bar2006-11-22 09:48 &lt;DIR&gt; .2006-11-22 09:48 &lt;DIR&gt; ..2006-11-16 11:58 0 foo-bar.log 1 File(s) 0 bytes 2 Dir(s) 1,107,345,408 bytes freeC:\tmp&gt; 说到这里，就会明白上面的那个命令 plink 192.168.6.200 date “+%F %T” 其实在主机上执行的真实命令是 date +%F %T，而不是命令行中指定的 date “+%F %T”。不过还好，Windows 的控制台可不认得单引号，所以上面那个命令的正确用法应该是：12c:\&gt;plink 192.168.6.200 date &apos;+%F %T&apos;2006-11-22 09:39:57 我经常需要登录到服务器上把 ADSL 重新拨号，可以把下面的命令写到一个文本文件中，比如保存到了 C:\adsl-restart.command.txt123456echo &quot;stoping...&quot;/sbin/adsl-stopecho &quot;starting...&quot;/sbin/adsl-startecho &quot;done.&quot;/sbin/adsl-status 然后执行如下命令： plink -m c:\adsl-restart.command.txt root@192.168.6.251我经常要查看 Tomcat 的运行日志 plink taylor@192.168.6.200 tail -f ~/apache-tomcat-5.5.17/logs/catalina.out每天都要看服务器上的剩余空间，就用这个命令： plink taylor@192.168.6.200 df -k假设 http://www.cnblogs.com/tippoint/admin/www.chaifeng.com 连接着另外一个网段 10.204.26.0，有台内网IP 为 10.204.26.21 的 Solaris 8主机只能用 telnet 登录，为了防止被监听，我们可以用 Plink 建立一个隧道，隧道开放 120 秒钟，如果隧道没有被使用，就自动断开连接，然后我们在本地就可以用命令 telnet localhost 2623 的安全登录那台 Solaris 8 主机了。12plink -L 2623:10.204.26.21:23http://www.cnblogs.com/tippoint/admin/www.chaifeng.comsleep 120 在主机 http://www.cnblogs.com/tippoint/admin/www.chaifeng.com 上正在运行着 tor，默认的监听地址是 127.0.0.1:9050，用 Plink 建立一个隧道，然后浏览器上配置代理服务器为 127.0.0.1，端口是 9050，这样就能够安全的使用 tor 代理了，不用担心从我们的机器到主机http://www.cnblogs.com/tippoint/admin/www.chaifeng.com 有被监听的可能了。12plink -C -N -L 9050:127.0.0.1:9050taylor@http://www.cnblogs.com/tippoint/admin/www.chaifeng.com 结合上 PSCP 我们还可以完成文件的每天备份123plink taylor@192.168.6.200 tar jcf $(date &apos;+documents.%F.tar.bz2&apos;) ~/documentspscp taylor@192.168.6.200:$(date &apos;+documents.%F.tar.bz2&apos;) c:\backup\plink taylor@192.168.6.200 rm -f $(date &apos;+documents.%F.tar.bz2&apos;) 如果把这些常用的操作写成批处理文件，到时候要重启一下 Tomcat，或者马上察看一下 Tomcat 日志，再或者只是要把 ADLS 重新拨号以下，只需要用鼠标一双击这个批处理文件，稍等一下就自动完成了。不比你打开 PuTTY，登录到服务器上，然后再一个一个的执行命令，最后还得注销来的方便快捷么？再懒一些，把自动备份的批处理放到计划任务里面，每天定时完成，哈 哈，有时间上网找些好玩的东西了，不用每天忙于这些繁杂重复的命令中了。 用假象去迷惑敌人如果我说 Google 的服务器也开放了 SSH，但是只有特定的 IP 可以连接上去，不信么？（声明：下面的图片都未经修改，我以 Google 的名义发誓，绝对没有 PS） 知道是怎么回事么？ FAQ（常见问题）我在 PuTTY 官方网站下载的，可是执行 PuTTY、Pagent、PuTTYgen 时总是出错，而命令行执行的这几个却没问题 这种情形我也碰到过，一个解决的办法就是去下载最新版，或许你碰巧下载的是旧版本。另外一个解决办法就是，创建三个扩展名为 .manifest 的文本文件，然后把这三个文件复制到 PuTTY 的目录中，文件内容分别如下：把下面的内容复制到记事本中，文件名保存为：PAGEANT.exe.manifest123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;!-- This is present purely to make Visual Styles in XP work better. See 20020104174954.A12067@imsa.edu. --&gt;&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;&lt;assemblyIdentity type="win32" name="Pageant" version="0.0.0.0" processorArchitecture="x86"/&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;!-- Load Common Controls 6 instead of 5 to get WinXP native- looking controls in the client area. --&gt; &lt;assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" publicKeyToken="6595b64144ccf1df" language="*" processorArchitecture="x86"/&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt;&lt;/assembly&gt; 把下面的内容复制到记事本中，文件名保存为：PUTTY.exe.manifest123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;!-- This is present purely to make Visual Styles in XP work better. See 20020104174954.A12067@imsa.edu. --&gt;&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;&lt;assemblyIdentity type="win32" name="PuTTY" version="0.0.0.0" processorArchitecture="x86"/&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;!-- Load Common Controls 6 instead of 5 to get WinXP native- looking controls in the client area. --&gt; &lt;assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" publicKeyToken="6595b64144ccf1df" language="*" processorArchitecture="x86"/&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt;&lt;/assembly&gt; 把下面的内容复制到记事本中，文件名保存为：PUTTYGEN.exe.manifest123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;!-- This is present purely to make Visual Styles in XP work better. See 20020104174954.A12067@imsa.edu. --&gt;&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;&lt;assemblyIdentity type="win32" name="PuTTYgen" version="0.0.0.0" processorArchitecture="x86"/&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;!-- Load Common Controls 6 instead of 5 to get WinXP native- looking controls in the client area. --&gt; &lt;assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" publicKeyToken="6595b64144ccf1df" language="*" processorArchitecture="x86"/&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt;&lt;/assembly&gt; 屏幕输出太快了，怎么能暂停一下？ Ctrl+S 快捷键可以暂停终端，Ctrl+Q 恢复。怎么翻页？ Shift+PageUp/PageDown 一页一页的翻，Ctrl+PageUp/PageDown 则是一行一行的。不是说 PSCP 一次只能传输一个文件么？为什么我发现能传输很多个？ 那是因为 PSCP 发现 SFTP 协议可用，优先使用 SFTP 协议来传输文件为什么执行了 pscp、psftp、plink 这些命令总是说错误的命令呢？ 应该把 PuTTY 所在的路径添加到 PATH 环境变量中。你可以编辑 c:\autoexec.bat 这个文件，在最后增加一行，把 c:\path\to\putty 换成你的真实路径set PATH=c:\path\to\putty;%PATH% 本文出自蛋炒饭的博客 http://yoursite.com/2017/09/17/putty详细使用说明/ 欢迎转载，转载请注明出处！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux putty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用C++进行QGis开发之]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%88%A9%E7%94%A8C-%E8%BF%9B%E8%A1%8CQGis%E5%BC%80%E5%8F%91%E4%B9%8B-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E5%9B%BE%E5%B1%82%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%A6%81%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[其实本文实现的功能类似于QGis中“添加文本数据图层”的一个简化版，本文不会涉及到对话框的使用，不通过与用户互交的方式创建要素，而是直接通过代码方式添加点要素，起到一个抛砖引玉的作用。 [TOC] 整个流程梳理 首先创建一个临时(memory)矢量图层 ; 将创建的图层添加到地图画布中 ; 创建几何要素 ; 将几何要素添加到矢量图层中 ; 更新图层范围并刷新画布 。 程序整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 测试代码/* "Point?crs=EPSG:4326&amp;field=id:integer&amp; * field=name:string(50)&amp;index=yes&amp; * memoryid=&#123;63152c31-9f38-4410-9983-fc9abe84973f&#125;" */QString layerProperties = "Point?"; // 几何类型layerProperties.append(QString( "crs=EPSG:4326&amp;" )); // 参照坐标系layerProperties.append(QString( "field=id:integer&amp;field=name:string(50)&amp;" )); // 添加字段layerProperties.append(QString( "index=yes&amp;" )); // 创建索引layerProperties.append(QString( // 临时编码"memoryid=%1" ).arg( QUuid::createUuid().toString() ));QgsVectorLayer* newLayer = new QgsVectorLayer( layerProperties, QString( "临时点层" ), QString( "memory" ) );if (!newLayer-&gt;isValid())&#123; return false;&#125;// 添加到地图QgsMapLayerRegistry::instance()-&gt;addMapLayer(newLayer);QgsVectorDataProvider* dateProvider = newLayer-&gt;dataProvider();// 创建点QgsFeature MyFeature;MyFeature.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4443, 32.2123)) );MyFeature.setAttributes(QgsAttributes() &lt;&lt; QVariant(1) &lt;&lt; QVariant("test"));QgsFeature MyFeature1;MyFeature1.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4643, 32.2133)) );MyFeature1.setAttributes(QgsAttributes() &lt;&lt; QVariant(2) &lt;&lt; QVariant("test1"));// 开始编辑newLayer-&gt;startEditing();// 添加要素dateProvider-&gt;addFeatures(QgsFeatureList() &lt;&lt; MyFeature &lt;&lt; MyFeature1);// 保存newLayer-&gt;commitChanges();// 更新范围newLayer-&gt;updateExtents();mMapCanvas-&gt;refresh();return true; 代码分析 创建临时图层 第3-11行，这段代码可能是我与网上其他的教程中比较不一样的地方，这里通过构造一种URL形式的字符串，通过上面的注释大家应该都大概明白这个字符串的意思了，通过这种形式很简洁方便的使我们将要创建的图层具备了多个条件，特别是简化对于图层字段的添加。 第7行 QString layerProperties = &quot;Point?&quot;定义了我们创建图层的几何类型，可以是&quot;Point&quot;、&quot;LineString&quot;、&quot;Polygon&quot;、&quot;MultiPoint&quot;、&quot;MultiLineString&quot;、&quot;MultiPolygon&quot;其中之一。 第8行QString( &quot;crs=EPSG:4326&amp;&quot; )是图层的参照坐标系，定义一个正确的坐标系是一个良好的习惯，如果需要一定灵活性可以参照QGis的方式通过对话框选取，或是根据自己的需求来实现，需要改变的仅仅是&quot;EPSG:4326&quot;而已。 第8行 QString( &quot;field=id:integer&amp;field=name:string(50)&amp;&quot; )是定义的图层字段，这也是我觉得很方便的一个地方，多个字段用&quot;&amp;&quot;进行连接，完整形式为 field=name:type(length,precision)，从参数看不仅可以定义长度还可以定义其精度。 第10行QString( &quot;index=yes&amp;&quot; )是定义空间索引，对于数据量较大的图层很有用。 第11行QString( &quot;memoryid=%1&quot; ).arg( QUuid::createUuid().toString() )比较有趣，它通过QUuid创建了一个全局唯一标识符（UUID），Qt中解释主要是用于分布式计算环境中的实体标识，而此处是用于当我们多次创建临时图层时的唯一标识符。 第3-5行就是一个URL形式字符串的完整展示，包含上述的所有内容，最后{}中一串数字就是通过QUuid自动创建的标识。虽然我没有尝试过，但是应该除了几何类型必须要定义以外，其他的都是可选项，当然如果我们采用这种方式肯定不仅仅是定义一个图层的几何类型而已。 上面准备工作说了很多，第13行才真正创建临时图层：QgsVectorLayer* newLayer = new QgsVectorLayer( layerProperties, QString( &quot;临时点层&quot; ), QString( &quot;memory&quot; ) ) QgsVectorLayer类有3个参数，第1个参数就是URL形式的字符串layerProperties，另外经常用的一种很简单的方式就是直接定义其图层的几何类型即可，如Point；第2个参数是图层的名称；第3个参数是创建图层的类型，这里传入的memory代表创建的是一个临时图层。 将图层添加到地图画布中 第21、23行将才创建的图层添加到地图画布中，并且获得一个QgsVectorDataProvider指针，该指针在后面会用到。 创建几何要素 第25-32行创建了两个点要素来展示结果，网上的很多例子为了让大家更清楚，是分开写的，我这个比较省事：MyFeature.setGeometry( QgsGeometry::fromPoint(QgsPoint(102.4443, 32.2123)) ) 使用setGeometry()设置了要素的几何体后，就继续用setAttributes()写入属性，属性类型、顺序与上面我们创建的是一致的，setAttributes()的参数是QgsAttributes对象，而QgsAttributes其实就是QVector&lt;QVariant&gt;，所用我下面代码中是添加的QVariant对象。MyFeature.setAttributes(QgsAttributes() &lt;&lt; QVariant(1) &lt;&lt; QVariant(&quot;test&quot;)) 通过上面的两行代码就成功创建了几何要素并设置了它的属性。 添加几何要素到矢量图层中 第34-41行我们利用上面获得的QgsVectorDataProvider指针将几何要素添加到了矢量图层中，我们先使用startEditing()来使图层可编辑，然后使用commitChanges()来提交改变结果。 刷新 最后更新图层范围，并刷新画布就OK了。 在这里多说一句，如果你按照此方法运行后，在地图画布上不能正常显示，检查下画布是否没有解冻，就是：mapCanvas()-&gt;freeze( false ) 我之前在这吃了亏，由于才接触QGis开发不久，我在程序的其他地方将画布冻结了，导致图层不能正常显示，自己捣鼓了很多次才发现。 效果图 QGis开发只是本人业余爱好，尽量将自己的一点学习心得与大家分享，如在上述内容中有不正确的地方，或有可以改进的地方欢迎大家指正。 本文出自蛋炒饭的博客 http://yoursite.com/2017/09/10/利用C-进行QGis开发之-创建临时图层并添加要素/ 欢迎转载，转载请注明出处！]]></content>
      <categories>
        <category>QGis</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>QGis</tag>
        <tag>二次开发</tag>
        <tag>创建临时图层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt中QScrollArea类的简单使用心得]]></title>
    <url>%2F2017%2F09%2F03%2FQt%E4%B8%ADQScrollArea%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[简要说明如何在QScrollArea滚动窗口中添加多个QWidget的使用方法。 根据自己目前的需求简单说下怎么在QScrollArea滚动窗口中实现多个控件的滚动显示，先看看最终效果： 先说一下在QScrollArea滚动窗口中要添加控件要使用QScrollArea::setWidget(QWidget * widget)这个函数，当添加的控件显示范围大于scrollArea则会出现滚动条，但是从名字可以看出这个函数是用于设置一个QWidget，而不能用于不断的添加QWidget，所以这里面并不能像大家想的那样来直接实现上面的效果，而是需要创建一个自己的QWidget，再在其中来添加自己需要的控件。 下面给出代码看看，由于我的滚动窗口是已经用设计器添加到对话框上的，所以我直接用ui-&gt;scrollArea来调用，buttonListWidget是我重新实现的QWidget子类，等会在下面可以看到实现代码：123buttonListWidget *buttonList = new buttonListWidget(this);buttonList-&gt;initWidget(strList);ui-&gt;scrollArea-&gt;setWidget(buttonList); buttonListWidget类，其实内容不多，但是主要是掌握到方法： buttonListWidget.h1234567891011class buttonListWidget : public QWidget&#123; Q_OBJECTpublic: explicit buttonListWidget(QWidget *parent = 0); void initWidget(QStringList&amp; nameList);signals:public slots:&#125;; buttonListWidget.cpp12345678910111213141516buttonListWidget::buttonListWidget(QWidget *parent) : QWidget(parent)&#123;&#125;void buttonListWidget::initWidget(QStringList &amp;nameList)&#123; QHBoxLayout *layout = new QHBoxLayout(this); foreach (QString str, nameList) &#123; QPushButton *button = new QPushButton(str, this); button-&gt;setMinimumSize(button-&gt;size()); layout-&gt;addWidget(button); &#125; this-&gt;setLayout(layout);&#125; 本文出自蛋炒饭的博客 http://yoursite.com/2017/09/03/Qt中QScrollArea类的简单使用心得/ 欢迎转载，转载请注明出处！]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QScrollArea</tag>
        <tag>滚动窗口</tag>
        <tag>QWidget</tag>
      </tags>
  </entry>
</search>
